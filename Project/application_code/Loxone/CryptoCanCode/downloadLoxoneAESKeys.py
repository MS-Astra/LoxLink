#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Tested with Loxone Miniserver version 10.3.11.27

import struct
import ftplib
import binascii
import io
import sys

loxoneMiniServerIP = '192.168.178.200'  # IP address of the Loxone Miniserver
adminUsername = '<<ADMIN USER>>'
adminPassword = '<<ADMIN PASSWORD>>'

if adminUsername == '<<ADMIN USER>>':
    print("Enter the correct IP addres of your Miniserver, the admin username and password in the script!")
    sys.exit(1)

def RSHash(key):
    # it seems a and b are switched by Loxone
    a = 63689
    hash = 0
    for i in range(len(key)):
        hash = hash * a + key[i]
        hash = hash & 0xFFFFFFFF
        a = a * 378551
    return hash
def JSHash(key):
    hash = 1315423911
    for i in range(len(key)):
        hash ^= (hash >> 2) + key[i] + (hash * 32)
        hash = hash & 0xFFFFFFFF
    return hash
def DJBHash(key):
    hash = 5381
    for i in range(len(key)):
        hash += hash * 32 + key[i]
        hash = hash & 0xFFFFFFFF
    return hash
def DEKHash(key):
    hash = len(key)
    for i in range(len(key)):
        hash = ((hash << 5) ^ (hash >> 27)) ^ key[i]
        hash = hash & 0xFFFFFFFF
    return hash

ftp = ftplib.FTP(loxoneMiniServerIP)
ftp.login(adminUsername, adminPassword)

ftp.cwd('update')

# get the firmware version number from the first file
version = ftp.nlst()[0].split(' ')[-1].split('_')[0]

# Load DigitalInputTree update into a buffer
sio = io.BytesIO()
def handle_binary(more_data):
    sio.write(more_data)
ftp.retrbinary("RETR %s_B1E1424BFF667AF471D715EE6745FDF0.upd" % version, callback=handle_binary)
filedata = sio.getvalue()

ftp.quit()

offset = filedata.rfind(binascii.unhexlify('A55A39')) # first 3 bytes of the master device ID
if offset >= 0:
    filedata = filedata[offset:]
    encryptedAESKey = filedata[12+16*3:12+16*4]
    encryptedAESIV = filedata[12+16*1:12+16*2]
    CryptoCanAlgoKey = [DEKHash(encryptedAESKey), JSHash(encryptedAESKey), DJBHash(encryptedAESKey), RSHash(encryptedAESKey)]
    CryptoCanAlgoIV = [DEKHash(encryptedAESIV), JSHash(encryptedAESIV), DJBHash(encryptedAESIV), RSHash(encryptedAESIV)]

    def hexCStr(buf):
        str = ''
        for val in buf:
            str += '0x%02x,' % val
        return str[:-1]

    f = open('secrets.c', 'w')
    f.write('#include "secrets.h"\n')
    f.write('\n')
    f.write('// The AES key/IV is generated by 4 hash functions from this data:\n')
    f.write('const uint8_t CryptoEncryptedAESKey[16] = { %s };\n' % hexCStr(encryptedAESKey))
    f.write('const uint8_t CryptoEncryptedAESIV[16] = { %s };\n' % hexCStr(encryptedAESIV))
    f.write('\n')
    f.write('//const uint32_t CryptoCanAlgoKey[4] = { DEKHash(CryptoEncryptedAESKey,sizeof(CryptoEncryptedAESKey)), JSHash(CryptoEncryptedAESKey,sizeof(CryptoEncryptedAESKey)), DJBHash(CryptoEncryptedAESKey,sizeof(CryptoEncryptedAESKey)), RSHash(CryptoEncryptedAESKey,sizeof(CryptoEncryptedAESKey)) };\n')
    f.write('const uint32_t CryptoCanAlgoKey[4] = { %#08x, %#08x, %#08x, %#08x };\n' % (CryptoCanAlgoKey[0],CryptoCanAlgoKey[1],CryptoCanAlgoKey[2],CryptoCanAlgoKey[3]))
    f.write('\n')
    f.write('//const uint32_t CryptoCanAlgoIV[4] = { DEKHash(CryptoEncryptedAESIV,sizeof(CryptoEncryptedAESIV)), JSHash(CryptoEncryptedAESIV,sizeof(CryptoEncryptedAESIV)), DJBHash(CryptoEncryptedAESIV,sizeof(CryptoEncryptedAESIV)), RSHash(CryptoEncryptedAESIV,sizeof(CryptoEncryptedAESIV)) };\n')
    f.write('const uint32_t CryptoCanAlgoIV[4] = { %#08x, %#08x, %#08x, %#08x };\n' % (CryptoCanAlgoIV[0],CryptoCanAlgoIV[1],CryptoCanAlgoIV[2],CryptoCanAlgoIV[3]))
    f.write('\n')
    f.write('const uint32_t CryptoCanAlgoLegacyKey[4] = { %#08x, %#08x, %#08x, %#08x };\n' % struct.unpack('<LLLL', filedata[12+16*2:12+16*3]))
    f.write('const uint32_t CryptoCanAlgoLegacyIV[4] = { %#08x, %#08x, %#08x, %#08x };\n' % struct.unpack('<LLLL', filedata[12+16*0:12+16*1]))
    f.write('\n')
    f.write('const uint8_t CryptoMasterDeviceID[12] = { %s };\n' % hexCStr(filedata[0:12]))
    f.close()
